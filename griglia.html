<!DOCTYPE html>
<html lang="it">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Programma 2: Pianificazione di Produzione (Fascia Oraria in Range)</title>
    
    <style>
        /* === STILE CSS === */
        body { font-family: Arial, sans-serif; margin: 20px; background-color: #f4f4f9; }
        h1 { color: #333; text-align: center; }
        .container { max-width: 1400px; margin: 0 auto; background: #fff; padding: 20px; border-radius: 8px; box-shadow: 0 4px 8px rgba(0, 0, 0, 0.1); }
        
        /* Navigazione */
        #btn_torna_al_registro { padding: 8px 15px; margin-bottom: 20px; background-color: #5c6bc0; color: white; border: none; border-radius: 5px; cursor: pointer; font-weight: bold; float: right; }

        /* Controlli e Paginazione */
        #controls { text-align: center; margin-bottom: 20px; display: flex; justify-content: space-between; align-items: center; }
        #controls button { padding: 10px 15px; background-color: #3f51b5; color: white; border: none; cursor: pointer; border-radius: 5px; font-weight: bold; }
        
        /* 1. Contenitore Scrollabile: Abilita lo scroll orizzontale */
        #tabella-container {
            overflow-x: auto; 
            overflow-y: hidden; 
            padding-bottom: 10px; 
            border: 1px solid #ddd; 
        }
        
        /* Stili Tabella */
        table { 
            width: 100%; 
            border-collapse: collapse; 
            margin-top: 10px; 
            table-layout: fixed; /* ESSENZIALE per larghezze fisse */
            border-spacing: 0; 
            min-width: 100%; 
        }
        th, td { border: 1px solid #ddd; padding: 4px; text-align: center; height: 35px; white-space: nowrap; }
        
        /* 2. Intestazioni Fisse (Sticky) Verticalmente */
        .tabella-pagina thead {
            position: sticky;
            top: 0;
            left: 0; 
            z-index: 10;
        }

        .header-ora, .header-minuto {
            position: sticky; 
            z-index: 10;      
        }
        .header-ora { background-color: #3f51b5; color: white; font-size: 14px; font-weight: bold; cursor: pointer; }
        
        /* COLONNE MINUTI: LARGHEZZA A 80px */
        .header-minuto { 
            background-color: #7986cb; 
            color: white; 
            font-size: 10px; 
            width: 80px; /* Larghezza 80px */
            top: 35px; 
        }

        /* CORREZIONE CRUCIALE: FORZA LA LARGHEZZA SULLE CELLE DATI */
        .tabella-pagina tbody td:not(.postazione-col) {
            width: 80px; /* Larghezza 80px */
        }
        
        /* 3. Colonna Postazioni Fisse (Sticky) Orizzontalmente */
        .postazione-col { 
            background-color: #607d8b; 
            color: white; 
            text-align: left; 
            width: 150px; /* Larghezza della colonna postazione rimane a 150px */
            padding: 8px; 
            position: sticky; 
            left: 0;          
            z-index: 15;      
        }

        /* 4. Cella d'Angolo (Fissa sia in alto che a sinistra) */

        /* Cella d'angolo superiore (Riga Ore) */
        .tabella-pagina thead tr:first-child .postazione-col {
            top: 0;
            z-index: 30; 
            background-color: #4a5d68; 
        }

        /* Cella d'angolo inferiore (Riga Minuti) */
        .tabella-pagina thead tr:last-child .postazione-col {
            top: 35px; 
            z-index: 30;
            background-color: #4a5d68;
        }

        /* Stile Cella Pausa: Rimuove pointer-events: none e rende il cursore normale */
        .break-cell { 
            background-color: #ffcdd2; 
            color: #c62828; 
            font-weight: bold; 
            cursor: pointer; /* Ora √® cliccabile */
            pointer-events: auto; /* Riabilita il click */
        }
        .break-cell:hover {
            filter: brightness(0.9);
        }

        /* Stili Interattivi */
        .task-cell, .free-cell { transition: background-color 0.2s; cursor: pointer; }
        .free-cell:hover { background-color: #e0e0e0; }
        .task-cell { color: white; font-size: 10px; font-weight: bold; border: 1px solid #555; }
        .task-cell:hover { filter: brightness(1.2); } /* Effetto hover visivo */
        
        /* CLASSI COLORE ODL */
        .task-fase-1 { background-color: #00bcd4; } 
        .task-fase-2 { background-color: #ff9800; } 
        .task-fase-3 { background-color: #4caf50; } 
        .task-fase-4 { background-color: #9c27b0; }
        .task-fase-5 { background-color: #f44336; }
        .task-fase-6 { background-color: #ffeb3b; }
        .task-fase-7 { background-color: #795548; } 
        .task-fase-8 { background-color: #03a9f4; } 
        .task-fase-9 { background-color: #e91e63; } 
        .task-fase-10 { background-color: #607d8b; } 
        
        /* Stili Bottoni Task */
        #selezione-fase button { 
            padding: 10px 15px; 
            margin: 5px; 
            border: 2px solid transparent; 
            color: white; 
            font-weight: bold; 
            cursor: pointer; 
            border-radius: 5px; 
            opacity: 0.8; 
            transition: opacity 0.2s, border 0.2s; 
            white-space: normal; 
            word-wrap: break-word;
        }
        #selezione-fase button.selected { border: 4px solid #333; opacity: 1; box-shadow: 0 0 10px rgba(0, 0, 0, 0.4); }
        .tabella-pagina { display: none; } 
        .tabella-pagina.active { display: table; } 
        
        /* --- NUOVI STILI PER MODALIT√Ä DI ALLOCAZIONE --- */

        /* Modalit√† Task Normale (Indicazione per l'inserimento) */
        body.task-mode .free-cell {
            border: 1px dashed #3f51b5; /* Bordo blu tratteggiato su celle libere */
            transition: background-color 0.2s, border-color 0.2s;
        }
        body.task-mode .free-cell:hover {
            background-color: #e3f2fd; /* Sfondo molto chiaro all'hover */
            cursor: crosshair; /* Cursore a mirino per suggerire il click di allocazione */
            border-color: #5c6bc0;
        }

        /* Modalit√† Cancellazione (Indicazione per la rimozione) */
        body.clear-mode .free-cell {
            border: 1px dashed #f44336; /* Bordo rosso tratteggiato su celle libere */
            transition: background-color 0.2s, border-color 0.2s;
        }
        body.clear-mode .free-cell:hover {
            background-color: #ffebee; /* Sfondo rosso chiaro all'hover */
            cursor: cell; /* Cursore a croce per suggerire la selezione di un'area */
            border-color: #c62828;
        }
    </style>
</head>
<body>

    <div class="container">
        <button id="btn_torna_al_registro">
            ‚Üê Torna al Registro Master (Programma 1)
        </button>
        <div style="clear: both;"></div> 
        
        <h1>Programma 2: Pianificazione di Produzione</h1>
        
        <div id="selezione-fase" style="text-align: center; margin-bottom: 20px;">
            <h3>1. Seleziona l'attivit√† OdL (Articolo - Fase - Tempo):</h3>
            <div id="container-bottoni-fasi">
                </div>
            <button id="btn-clear-5min" data-task-name="Libero 5min" data-task-class="clear-5-min" data-task-tempo-minuti="5" style="background-color: #ddd; color: #333;">Cancella/Libera (5 min)</button>
            <button id="btn-clear-60min" data-task-name="Libero 60min" data-task-class="clear-60-min" data-task-tempo-minuti="60" style="background-color: #f44336; color: white;">Cancella Range (60 min)</button>
            
            <p id="stato-selezione" style="font-weight: bold; margin-top: 10px;">Stato: Seleziona un Task.</p>
        </div>
        
        <hr>

        <div id="controls">
            <button id="prev-page" disabled>&lt;&lt; Indietro</button>
            <span id="page-info" style="font-weight: bold;">Caricamento...</span>
            <button id="next-page">Avanti &gt;&gt;</button>
        </div>
        
        <h3>2. Clicca su un blocco di 5 minuti per allocare un nuovo task, o clicca su un task esistente per vedere i dettagli:</h3>
        <div id="tabella-container"></div>
    </div>

    <script>
        // --- CHIAVI LOCALSTORAGE ---
        const CHIAVE_POSTAZIONI = 'registroMasterPostazioni';
        const CHIAVE_ODL = 'registroOrdiniDiLavoro'; 
        // NUOVA CHIAVE PER LA PERSISTENZA DEI DATI DI ALLOCAZIONE
        const CHIAVE_ALLOCAZIONI = 'datiAllocazionePianificazione'; 

        let listaPostazioni = []; 
        let ordiniDiLavoro = []; 
        let datiAllocazione = {}; // Sar√† caricato da localStorage

        // --- CONFIGURAZIONE TEMPORALE ---
        const ORE_DA_COPRIRE = 160; 
        const ORE_DI_LAVORO_PER_PAGINA = 8; 
        const ORE_DI_PAUSA_PER_PAGINA = 1;  
        const ORA_INIZIO_FISSA = 8;         
        const INTERVALLO_MINUTI = 5; 

        // --- CALCOLI DERIVATI ---
        const slotPerOra = 60 / INTERVALLO_MINUTI; // 12 slot
        const ORE_DI_DISPLAY_PER_PAGINA = ORE_DI_LAVORO_PER_PAGINA + ORE_DI_PAUSA_PER_PAGINA; 
        const SLOTS_PER_LAVORO = ORE_DI_LAVORO_PER_PAGINA * slotPerOra; 
        const SLOTS_PER_DISPLAY = ORE_DI_DISPLAY_PER_PAGINA * slotPerOra; 
        const NUMERO_PAGINE = Math.ceil(ORE_DA_COPRIRE / ORE_DI_LAVORO_PER_PAGINA); 
        const MAX_SLOTS_GLOBALI = ORE_DA_COPRIRE * slotPerOra;
        
        // Pausa (es: 12:30 - 13:30)
        const SLOTS_PAUSA_DURATA = 60 / INTERVALLO_MINUTI; // 12 slot
        const SLOTS_PRIMA_PAUSA = (4 * slotPerOra) + (30 / INTERVALLO_MINUTI); // 4 ore e 30 minuti = 54 slot lavorativi
        const SLOTS_PAUSA_INIZIO_DISPLAY = SLOTS_PRIMA_PAUSA; 
        
        // --- VARIABILI GLOBALI ---
        let taskSelezionato = null;
        let currentPage = 0; 
        
        
        // --- FUNZIONE PER SALVARE I DATI DI ALLOCAZIONE ---
        function salvaAllocazione() {
            try {
                localStorage.setItem(CHIAVE_ALLOCAZIONI, JSON.stringify(datiAllocazione));
            } catch (e) {
                console.error("Errore nel salvataggio dei dati di allocazione:", e);
            }
        }

        // --- FUNZIONE DI CARICAMENTO DATI MASTER (AGGIORNATA PER LA PERSISTENZA) ---
        function caricaDatiMaster() {
            try {
                const postazioniJson = localStorage.getItem(CHIAVE_POSTAZIONI);
                listaPostazioni = postazioniJson ? JSON.parse(postazioniJson) : ["A1 - Default"];

                const odlJson = localStorage.getItem(CHIAVE_ODL);
                ordiniDiLavoro = odlJson ? JSON.parse(odlJson) : [];
                
                // Caricamento dei Dati di Allocazione salvati
                const allocazioniJson = localStorage.getItem(CHIAVE_ALLOCAZIONI);
                datiAllocazione = allocazioniJson ? JSON.parse(allocazioniJson) : {};

            } catch (e) {
                console.error("Errore nel caricamento dei dati master:", e);
            }
        }
        
        // --- GENERAZIONE BOTTONI DALL'ODL (AGGIORNATA) ---
        
        function generaBottoniFasi() {
            const container = document.getElementById('container-bottoni-fasi');
            container.innerHTML = ''; 

            if (ordiniDiLavoro.length === 0) {
                container.innerHTML = '<p style="color: red; font-weight: bold;">Nessun Ordine di Lavoro (OdL) trovato. Torna al Registro (Programma 1) per definirli.</p>';
                return;
            }

            ordiniDiLavoro.forEach((odl, odlIndex) => {
                odl.fasi.forEach((fase, faseIndex) => {
                    const btn = document.createElement('button');
                    
                    const nomeCompleto = `${odl.id} - ${fase.name} (${fase.tempo}m)`; 
                    
                    btn.textContent = nomeCompleto;
                    btn.dataset.taskName = nomeCompleto;
                    btn.dataset.taskClass = fase.class;
                    btn.dataset.taskTempoMinuti = fase.tempo; 
                    
                    btn.classList.add(fase.class); 
                    container.appendChild(btn);
                    
                    // Imposta il primo task come selezionato di default e attiva la modalit√† visiva
                    if (odlIndex === 0 && faseIndex === 0) {
                        taskSelezionato = { 
                            name: nomeCompleto, 
                            class: fase.class,
                            tempo: fase.tempo 
                        };
                        btn.classList.add('selected');
                        document.getElementById('stato-selezione').textContent = `Stato: Task selezionato: ${nomeCompleto}`;
                        document.body.classList.add('task-mode'); // Attiva la modalit√† visiva
                    }
                });
            });
            
            // Inizializza gli array per le postazioni se non esistono o se la lunghezza non corrisponde
            listaPostazioni.forEach(p => {
                if (!datiAllocazione[p] || datiAllocazione[p].length !== MAX_SLOTS_GLOBALI) {
                    datiAllocazione[p] = Array(MAX_SLOTS_GLOBALI).fill(null);
                }
            });
            
            document.querySelectorAll('#selezione-fase button').forEach(btn => {
                btn.addEventListener('click', gestisciSelezioneBottone);
            });
        }
        
        // --- FUNZIONE AGGIORNATA: GESTIONE SELEZIONE BOTTONE E MODALIT√Ä VISIVA ---
        function gestisciSelezioneBottone(event) {
            const bottoneCliccato = event.currentTarget;
            document.querySelectorAll('#selezione-fase button').forEach(btn => {
                btn.classList.remove('selected');
            });

            const taskName = bottoneCliccato.dataset.taskName;
            const taskClass = bottoneCliccato.dataset.taskClass;
            const tempoMinuti = parseInt(bottoneCliccato.dataset.taskTempoMinuti); 

            taskSelezionato = { name: taskName, class: taskClass, tempo: tempoMinuti };
            bottoneCliccato.classList.add('selected');

            const statoElement = document.getElementById('stato-selezione');
            const body = document.body;

            // Rimuovi classi di modalit√† precedenti
            body.classList.remove('task-mode', 'clear-mode');
            
            // Logica Aggiornata per i bottoni di Cancellazione
            if (taskClass.startsWith('clear-')) { 
                statoElement.textContent = `Stato: Modalit√† Cancellazione Range Attiva (${tempoMinuti} min). Clicca sullo slot di inizio.`;
                statoElement.style.color = 'red';
                body.classList.add('clear-mode'); // Aggiunge la classe per la modalit√† Cancella
            } else {
                statoElement.textContent = `Stato: Task selezionato: ${taskName} (Tempo: ${tempoMinuti} min)`;
                statoElement.style.color = window.getComputedStyle(bottoneCliccato).backgroundColor || 'black';
                body.classList.add('task-mode'); // Aggiunge la classe per la modalit√† Task
            }
        }
        
        // --- FUNZIONE PER OTTENERE L'ORA E IL GIORNO A PARTIRE DALLO SLOT GLOBALE ---
        function ottieniOraEData(slotGlobale) {
            const minutiTotali = slotGlobale * INTERVALLO_MINUTI;
            const oreTotali = minutiTotali / 60;
            const giorniTrascorsi = Math.floor(oreTotali / ORE_DI_LAVORO_PER_PAGINA);
            
            let minutiLavoratiNelGiorno = minutiTotali - (giorniTrascorsi * ORE_DI_LAVORO_PER_PAGINA * 60);

            // Calcolo dell'Ora d'Inizio Reale (tenendo conto della pausa)
            const slotPausaInizio = SLOTS_PRIMA_PAUSA * INTERVALLO_MINUTI; 
            const slotPausaFine = (SLOTS_PRIMA_PAUSA + SLOTS_PAUSA_DURATA) * INTERVALLO_MINUTI; 
            
            let minutiOraInizio = ORA_INIZIO_FISSA * 60 + minutiLavoratiNelGiorno;
            
            if (minutiOraInizio >= slotPausaInizio + (ORA_INIZIO_FISSA * 60)) {
                // Se lo slot cade dopo l'inizio pausa (12:30), aggiungiamo la durata pausa (60min)
                minutiOraInizio += 60; 
            }
            
            const oraReale = Math.floor(minutiOraInizio / 60);
            const minutoReale = minutiOraInizio % 60;

            const giorno = giorniTrascorsi + 1;
            const orarioStringa = `${String(oraReale).padStart(2, '0')}:${String(minutoReale).padStart(2, '0')}`;
            
            return { giorno, orarioStringa };
        }
        
        // --- NUOVA FUNZIONE: MOSTRA DETTAGLI PAUSA ---
        function mostraDettagliPausa(event) {
            const cella = event.currentTarget;
            const postazione = cella.dataset.postazione;
            const ora = "12:30"; 
            const fine = "13:30";
            
            alert(`PAUSA PRANZO üçΩÔ∏è\n\nQuesta fascia oraria (dalle ${ora} alle ${fine}) √® riservata e non allocabile per la Postazione ${postazione}.`);
        }
        
        // --- MOSTRA DETTAGLI TASK ALLOCATO ---
        function mostraDettagliTask(postazione, slotGlobale) {
            const assegnazione = datiAllocazione[postazione] ? datiAllocazione[postazione][slotGlobale] : null;
            
            if (assegnazione && assegnazione.name) {
                // Cerchiamo l'inizio del task per trovare il tempo totale allocato
                let slotInizio = slotGlobale;
                while (slotInizio > 0 && datiAllocazione[postazione][slotInizio - 1] && datiAllocazione[postazione][slotInizio - 1].name === assegnazione.name) {
                    slotInizio--;
                }

                // Troviamo il primo slot con il tempo totale salvato (se non √® null)
                const taskInizioDati = datiAllocazione[postazione][slotInizio];
                const tempoTotale = taskInizioDati && taskInizioDati.tempo ? taskInizioDati.tempo : 'N.D.';

                const dataOra = ottieniOraEData(slotInizio);

                const messaggio = `
                    **DETTAGLI TASK ALLOCATO**
                    --------------------------
                    Postazione: ${postazione}
                    Task: ${assegnazione.name}
                    Tempo stimato: ${tempoTotale} minuti
                    Inizio: Giorno ${dataOra.giorno}, ${dataOra.orarioStringa}
                    Classe: ${assegnazione.class}
                `;
                
                alert(messaggio);
            }
        }
        
        // --- MOSTRA DETTAGLI ORA ---
        function mostraDettagliOra(event) {
            const thOra = event.currentTarget;
            const oraText = thOra.textContent;
            
            alert(`Fascia oraria selezionata: ${oraText}\n\nPer allocare o visualizzare i dettagli, clicca sulla riga dei minuti sottostante.`);
        }


        // --- GENERAZIONE GRIGLIA ---
        
        function generaGrigliePaginazione() {
            const container = document.getElementById('tabella-container');
            container.innerHTML = ''; 

            if (listaPostazioni.length === 0) {
                 container.innerHTML = '<p style="text-align: center; color: red; font-weight: bold;">ATTENZIONE: Nessuna postazione di lavoro definita. Torna al Registro (Programma 1) per definirle.</p>';
                 return;
            }
            
            for (let paginaIdx = 0; paginaIdx < NUMERO_PAGINE; paginaIdx++) {
                const tabella = document.createElement('table');
                tabella.classList.add('tabella-pagina');
                tabella.id = `page-${paginaIdx}`;
                const thead = tabella.createTHead();
                const rigaOre = thead.insertRow();
                const rigaMinuti = thead.insertRow();
                
                // Cella d'angolo (Postazione)
                rigaOre.insertCell().classList.add('postazione-col'); 
                rigaMinuti.insertCell().classList.add('postazione-col'); 

                const etichettaGiorno = `Giorno ${paginaIdx + 1}`;
                
                for (let i = 0; i < ORE_DI_DISPLAY_PER_PAGINA; i++) {
                    const oraVisualizzata = ORA_INIZIO_FISSA + i; 
                    let thOra = document.createElement("th");
                    
                    // Fascia oraria in formato "Dalle HH:00 alle HH+1:00"
                    const oraInizio = String(oraVisualizzata).padStart(2, '0');
                    const oraFine = String(oraVisualizzata + 1).padStart(2, '0');
                    thOra.textContent = `${etichettaGiorno} - Dalle ${oraInizio}:00 alle ${oraFine}:00`;
                    
                    thOra.colSpan = slotPerOra; 
                    thOra.classList.add('header-ora');
                    thOra.dataset.oraIndexDisplay = i; 
                    thOra.dataset.pageIndex = paginaIdx;
                    
                    thOra.addEventListener('click', mostraDettagliOra); 
                    
                    rigaOre.appendChild(thOra);

                    for (let m = 0; m < 60; m += INTERVALLO_MINUTI) {
                        let thMinuto = document.createElement("th");
                        thMinuto.textContent = String(m).padStart(2, '0');
                        thMinuto.classList.add('header-minuto');
                        rigaMinuti.appendChild(thMinuto);
                    }
                }

                const tbody = tabella.createTBody();
                const slotInizioGlobale = paginaIdx * SLOTS_PER_LAVORO; 
                
                listaPostazioni.forEach((nomePostazione) => { 
                    const riga = tbody.insertRow();
                    let cellaPostazione = riga.insertCell();
                    cellaPostazione.textContent = nomePostazione;
                    cellaPostazione.classList.add('postazione-col'); 
                    
                    for (let i_display = 0; i_display < SLOTS_PER_DISPLAY; i_display++) {
                        const cella = riga.insertCell();
                        const isBreakSlot = i_display >= SLOTS_PAUSA_INIZIO_DISPLAY && i_display < SLOTS_PAUSA_INIZIO_DISPLAY + SLOTS_PAUSA_DURATA;

                        if (isBreakSlot) {
                            cella.textContent = ""; 
                            cella.classList.add('break-cell');
                            cella.dataset.postazione = nomePostazione; 
                            cella.addEventListener('click', mostraDettagliPausa); 
                        } else {
                            let slotLocaleLavorativo = i_display;
                            if (i_display >= SLOTS_PAUSA_INIZIO_DISPLAY + SLOTS_PAUSA_DURATA) {
                                slotLocaleLavorativo -= SLOTS_PAUSA_DURATA; 
                            }
                            
                            const slotGlobale = slotInizioGlobale + slotLocaleLavorativo;
                            
                            cella.dataset.postazione = nomePostazione;
                            cella.dataset.slot = slotGlobale; 
                            
                            const assegnazione = datiAllocazione[nomePostazione] ? datiAllocazione[nomePostazione][slotGlobale] : null; 
                            if (assegnazione) {
                                cella.textContent = assegnazione.name.split('(')[0]; 
                                cella.classList.add('task-cell', assegnazione.class);
                            } else {
                                cella.classList.add('free-cell');
                            }
                            cella.addEventListener('click', gestisciClickCella); 
                        }
                    }
                });
                container.appendChild(tabella);
            }
            mostraPagina(currentPage);
        }

        function mostraPagina(pageIndex) {
            currentPage = pageIndex;
            const giornoCorrente = `Giorno ${pageIndex + 1}`;
            
            document.getElementById('page-info').textContent = 
                `${giornoCorrente} (Pianificazione 08:00 - 17:00)`; 
            
            document.getElementById('prev-page').disabled = currentPage === 0;
            document.getElementById('next-page').disabled = currentPage === NUMERO_PAGINE - 1;

            document.querySelectorAll('.tabella-pagina').forEach((table, index) => {
                table.style.display = 'none'; 
                if (index === pageIndex) {
                    table.style.display = 'table'; 
                }
            });
        }
        
        function aggiornaCellaVisiva(postazione, slot, taskName, taskClass) {
            const cella = document.querySelector(`td[data-postazione="${postazione}"][data-slot="${slot}"]`);
            if (cella) {
                cella.className = ''; 
                if (taskClass.startsWith('clear-') || taskClass === 'free-cell') { 
                    cella.textContent = '';
                    cella.classList.add('free-cell'); 
                } else {
                    // Visualizza il nome solo sul primo slot del task
                    const isPrimoSlot = datiAllocazione[postazione][slot] && datiAllocazione[postazione][slot].tempo !== null;
                    cella.textContent = isPrimoSlot ? taskName.split('(')[0] : ''; 
                    cella.classList.add('task-cell', taskClass);
                }
            }
        }
        
        // --- LOGICA CHIAVE: Allocazione multi-slot automatica e Gestione Cancellazione Range (AGGIORNATA CON SALVATAGGIO) ---
        function gestisciClickCella(event) {
            const cellaCliccata = event.currentTarget;
            const postazione = cellaCliccata.dataset.postazione;
            const slotInizialeGlobale = parseInt(cellaCliccata.dataset.slot); 
            
            if (!taskSelezionato) {
                alert("Per favore, seleziona prima un Task.");
                return;
            }

            const assegnazione = datiAllocazione[postazione] ? datiAllocazione[postazione][slotInizialeGlobale] : null;

            // 1. GESTIONE MODALIT√Ä CANCELLAZIONE RANGE (5 MIN o 60 MIN)
            if (taskSelezionato.class.startsWith('clear-')) {
                const slotsToClear = Math.ceil(taskSelezionato.tempo / INTERVALLO_MINUTI);
                const isClear5Min = slotsToClear === 1;
                
                if (!isClear5Min && !confirm(`Confermi di voler liberare ${slotsToClear * INTERVALLO_MINUTI} minuti (${slotsToClear * INTERVALLO_MINUTI / 60} ora) a partire da questo slot?`)) {
                    return;
                }

                let slotsCleared = 0;
                let dataChanged = false;

                // Loop per cancellare il numero richiesto di slot LAVORATIVI
                for (let i = 0; slotsCleared < slotsToClear; i++) {
                    let slotCorrente = slotInizialeGlobale + i;
                    
                    if (slotCorrente >= MAX_SLOTS_GLOBALI) break;

                    const cellaCorrenteVisuale = document.querySelector(`td[data-postazione="${postazione}"][data-slot="${slotCorrente}"]`);

                    // Controlla se lo slot corrente (globale) corrisponde a una pausa pranzo VISIBILE
                    if (cellaCorrenteVisuale && cellaCorrenteVisuale.classList.contains('break-cell')) {
                        // Salta l'intera durata della pausa (12 slot)
                        i += SLOTS_PAUSA_DURATA - 1; // -1 perch√© i++ verr√† eseguito alla fine del ciclo
                        continue; 
                    }
                    
                    // Cancella Dati
                    if (datiAllocazione[postazione][slotCorrente] !== null) {
                         datiAllocazione[postazione][slotCorrente] = null;
                         dataChanged = true;
                    }
                    
                    // Aggiorna Visuals (solo se la cella √® attualmente visibile)
                    if (cellaCorrenteVisuale) {
                         aggiornaCellaVisiva(postazione, slotCorrente, '', 'free-cell'); 
                    }
                    
                    slotsCleared++;
                }
                
                if (dataChanged) salvaAllocazione();
                return;
            }

            // 2. GESTIONE TASK NORMALE (Allocazione o Dettagli)
            if (assegnazione) {
                // Task Normale attivo: mostra i dettagli del task esistente.
                mostraDettagliTask(postazione, slotInizialeGlobale);
                return; 
            }
            
            // 3. CELLA LIBERA: ALLOCA UN NUOVO TASK
            
            const { name: taskName, class: taskClass, tempo } = taskSelezionato;
            
            const slotsDaAllocare = Math.ceil(tempo / INTERVALLO_MINUTI);
            const limiteGlobale = MAX_SLOTS_GLOBALI;

            let slotsAllocati = 0;
            let dataChanged = false;

            for (let i = 0; slotsAllocati < slotsDaAllocare; i++) {
                let slotCorrente = slotInizialeGlobale + i;
                
                // Controllo Limite
                if (slotCorrente >= limiteGlobale) {
                    alert(`Attenzione: solo ${slotsAllocati * INTERVALLO_MINUTI} minuti di ${tempo} minuti sono stati allocati prima della fine della pianificazione.`);
                    break;
                }

                const cellaCorrente = document.querySelector(`td[data-postazione="${postazione}"][data-slot="${slotCorrente}"]`);

                // Controllo Pausa (visiva)
                if (cellaCorrente && cellaCorrente.classList.contains('break-cell')) {
                    // Salta l'intera pausa (12 slot) e continua l'allocazione dopo
                    i += SLOTS_PAUSA_DURATA - 1; // -1 perch√© i++ verr√† eseguito alla fine del ciclo
                    continue; 
                }
                
                // Controllo Sovrapposizione (dati)
                const assegnazioneEsistente = datiAllocazione[postazione][slotCorrente];
                if (assegnazioneEsistente) {
                     alert(`Impossibile allocare l'intero Task per sovrapposizione con: ${assegnazioneEsistente.name}`);
                    return; 
                }


                // Allocazione Dati
                datiAllocazione[postazione][slotCorrente] = { 
                    name: taskName, 
                    class: taskClass, 
                    // Tempo totale salvato SOLO sul primo slot
                    tempo: (slotsAllocati === 0) ? tempo : null 
                };
                dataChanged = true;
                
                // Aggiornamento Visivo
                aggiornaCellaVisiva(postazione, slotCorrente, taskName, taskClass);
                
                slotsAllocati++;
            }
            
            if (dataChanged) salvaAllocazione();
        }

        // --- INIZIALIZZAZIONE COMPLETA ---
        document.addEventListener('DOMContentLoaded', () => {
            caricaDatiMaster(); // Carica dati master e allocazioni salvate
            generaBottoniFasi(); // Genera i bottoni e imposta la prima selezione
            generaGrigliePaginazione(); // Genera la griglia con i dati caricati
            
            document.getElementById('prev-page').addEventListener('click', () => {
                if (currentPage > 0) mostraPagina(currentPage - 1);
            });
            document.getElementById('next-page').addEventListener('click', () => {
                if (currentPage < NUMERO_PAGINE - 1) mostraPagina(currentPage + 1);
            });
            
            document.getElementById('btn_torna_al_registro').addEventListener('click', () => {
                // Sostituire con il nome file corretto del Programma 1
                // Assicurati che il Programma 1 si chiami 'registro_fasi_master.html'
                window.location.href = 'index.html'; 
            });

            mostraPagina(currentPage); 
        });

    </script>
</body>
</html>
